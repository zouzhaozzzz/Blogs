# 经验总结

## 1、子类和父类之间构造方法

1.

| 情况 | 父类 | 子类 | 输出情况       |
| ---- | ---- | ---- | -------------- |
| 无参 | ✔    | ✔    | 先输出父类无参 |
| 有参 |      |      | 再输出子类无参 |

2.

| 情况 | 父类 | 子类 | 输出情况       |
| ---- | ---- | ---- | -------------- |
| 无参 | ✔    |      | 先输出父类无参 |
| 有参 |      | ✔    | 再输出子类有参 |

3.

| 情况 | 父类 | 子类 | 输出情况 |
| ---- | ---- | ---- | -------- |
| 无参 |      | ✔    | 报错     |
| 有参 | ✔    |      |          |

4.

| 情况 | 父类 | 子类 | 输出情况       |
| ---- | ---- | ---- | -------------- |
| 无参 |      |      | 先输出父类有参 |
| 有参 | ✔    | ✔    | 再输出子类有参 |

5.

| 情况 | 父类 | 子类 | 输出情况       |
| ---- | ---- | ---- | -------------- |
| 无参 | ✔    | ✔    | 先输出父类无参 |
| 有参 | ✔    |      | 再输出子类无参 |

6.

| 情况 | 父类 | 子类                        | 输出情况       |
| ---- | ---- | --------------------------- | -------------- |
| 无参 | ✔    |                             | 先输出父类无参 |
| 有参 | ✔    | ✔（无super或者有super（）） | 再输出子类有参 |

6.

| 情况 | 父类       | 子类              | 输出情况       |
| ---- | ---------- | ----------------- | -------------- |
| 无参 | ✔          |                   | 先输出父类有参 |
| 有参 | ✔（int i） | ✔（有super（i）） | 再输出子类有参 |

7.

| 情况 | 父类 | 子类 | 输出情况         |
| ---- | ---- | ---- | ---------------- |
| 无参 | ✔    | ✔    | 综合上述         |
| 有参 | ✔    | ✔    | 视使用情况而输出 |



## 2、父子类中各个资源的初始化顺序 

 静态优先，然后是父类型优先

```java
// 1、父亲的静态属性 (1)
// 2、子类的静态属性 (1)
// 3、初始化父亲中的属性
// 4、构造父亲实例
// 5、初始化子类中的属性
// 6、构造子类实例
```


## 3、子类和父类中调用方法的顺序

```java
Super s=new Super();	//父类
Sub b=new Sub)();		//子类
```

- 采用**就近原则**
- 创建的对象是子类时，父类和子类都有这个方法时，就用子类的方法

- 创建的对象是子类时，父类有该方法，子类没有，调用父类的方法

- 创建的对象是父类时，只能使用父类的方法



## 4、多态以及方法的调用

- 多态

  > 简单地说就是：父类的引用指向了子类对象，接口的引用指向了其接口的实现类对象
  >
  > - 一个行为，在不同条件下，有不同的执行效果
  > - 在定义方法的时候，我们可以把参数类型定义的更为抽象一些，这样它就能接受所有的自类型实例，以此来提高程序的兼容性
  >
  > - 前提条件：必须存在继承或实现关系
  >
  > - 表现：重写是父类与子类之间多态性的一种表现，重载是一类中多态性的表现



- 父类  character =new 子类

  ~~~java
   Super e=new Sub();
  ~~~

- **能做什么看左边，具体做什么看右边**
  - 父类中有而子类没有的方法，使用父类
  - 父类和子类都有该方法时，使用子类重写的方法



- 父类的引用指向了子类对象（继承父类进行方法重写）

~~~java
public class Parent {
 
    public void fun(){}
}
 
public class Child extends Parent {

    @Override
    public void fun(){
        //子类的重写
    }
}

public class Demo1 {
	
	public static void main(String[] args) {
		Parent parent = new Child();
		parent.fun();
	}
}
~~~

- 同一个类中进行方法重载

  > 方法的重载：需参数不同、参数个数不同、返回值不同

~~~java
public void init(String name,int i){
        
}
    
public void init(int i,String name){
        
}
    
public void init(){
        
}
    
public int init(){
        
}
~~~



## 5、学生系统结构分析

Main	--主函数入口

StudentManager	--管家婆：定为属于高层管理，主要负责安排和协调工作的

StudentContainer、Console	--控制台、数据容器：中层管理，提供特定的服务、数据，这两者都直接与管家婆对接

自我感觉：精益求精，先列出StudentManager列出大概步骤，再通过下层实现具体方法



## 6、类型准换

- 主要分为向上（自动）和向下转型（需要在变量前面加以类型修饰）

  ~~~java
  Sub a=new Sub();
  Super s=a;
  
  Super a=new Super();
  Sub b=(Sub)a;
  ~~~

  

- 对于基本类型而言，比如数字，可以把长度小的类型自动转换成长度大的，相反，长度大的也可以强制类型转化为长度小的

  ~~~java
  byte(1字节)->short(2字节)->int(4字节)->long(8字节)->float(4字节)->double(8字节)
      	^
      	|
         char(2字节)
  ~~~

  

- 当把子类型转换为父类型的时候，这个实例的行为会变成它只能调用父类型声明的那些方法（能做什么看左边的类型，具体怎么做，看右边是什么样的实例）

  - 用法类似如多态

  

- 变量名 instanceof 类型：前者是后者这个类型的一个实例吗？

~~~java
Super n=new Sub();
 n instanceof Sub	结果：true
~~~



## 7、如何比较对象

- 如何比较对象
  - ==用来比较两者的地址(引用)，基本类型直接比较值
  - 我们如果要实现"当这个对象中某些个属性值相等，我们就认为这是两个相同的对象"，可以使用equals
  - 重写Object的equals方法（默认比较的是地址）
  - 比如用户在注册论坛的时候，我们可以在后台的User中，增加手机号码 + 性别 + 用户名



## 8、静态修饰符(static)的使用	

- static修饰的变量，它不依赖类的实例而存在，一般直接通过类名进行调用，它是这个类的实例所有共有的（它只有一份）
- 静态方法只能引用静态变量和静态方法
- **static一般都"只执行一次"或者"只有一份"**



## 9、final修饰符

- 被final修饰的变量，具有"不可改变"的特性，可以在构造器中进行第一次赋值初始化
- 修饰基本类型：其值不可以再进行修改
- 修饰引用类型：可以改 - 地址没有变
- 修饰类：这是这个类的最终版，不能被扩展和继承
- 修饰方法：这是这个方法的最终版，不能被重写







# 问题收纳

## 1、如何理解类和对象

- 定义：类是关于一系列相似对象的概括描述，描述它们共有的状态、行为，通过这种共性的定义，我们可以重构出许许多多类似的对象。

​		而对象，即是根据上述类的定义，“克隆”产生的相关实例，这些实例往往在某些属性或行为上是类似但有细节不同的，比如都有姓名，但具体的名字不同。

- 组成类大体包含两种要素，我们统称为成员：
  - 成员变量：体现为属性、状态、数据
  - 成员方法：体现为函数或方法，或者做某件事情的能力

- 关系：类与对象之间的关系：当我们依照类A创建了a1实例的时候，我们可以说 a1 is a member of A



## 2、如何理解封装和抽象

- 封装（动词），既可以用于封装类型，也可以用于封装方法。

- 在封装类型的时候，即是把这个类型的2要素（成员变量和方法）包装到一个单元（class 文件）里面

- 在封装方法的时候，即是把专注做“某件事情”（执行某一个特定算法）的代码段用方法体包含起来

- 在封装的时候，要用“抽象”这种思维能力，做到关注主要的（所有实例共有的），忽略次要的（特别的，只有某些特殊实例才具备的）。

- 抽象还体现在，当我们使用一个类型的实例的时候，在调用其方法时，只需要关注有哪些入参，可以得到什么返回，而无需关注内部的具体实现方式或细节

























