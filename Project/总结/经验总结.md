# 经验总结

## 1、子类和父类之间构造方法

1.

| 情况 | 父类 | 子类 | 输出情况       |
| ---- | ---- | ---- | -------------- |
| 无参 | ✔    | ✔    | 先输出父类无参 |
| 有参 |      |      | 再输出子类无参 |

2.

| 情况 | 父类 | 子类 | 输出情况       |
| ---- | ---- | ---- | -------------- |
| 无参 | ✔    |      | 先输出父类无参 |
| 有参 |      | ✔    | 再输出子类有参 |

3.

| 情况 | 父类 | 子类 | 输出情况                  |
| ---- | ---- | ---- | ------------------------- |
| 无参 |      | ✔    | 报错                      |
| 有参 | ✔    |      | 改错方式：1、创建父类无参 |

~~~java
改错方式2、在子类无参构造里面使用父类有参
    class Super{
        public Super(int i){}
    }
    class Sub extends Super{
        public Sub(){
            super(10);
        }
    }
~~~



4.

| 情况 | 父类 | 子类 | 输出情况       |
| ---- | ---- | ---- | -------------- |
| 无参 |      |      | 先输出父类有参 |
| 有参 | ✔    | ✔    | 再输出子类有参 |

5.

| 情况 | 父类 | 子类 | 输出情况       |
| ---- | ---- | ---- | -------------- |
| 无参 | ✔    | ✔    | 先输出父类无参 |
| 有参 | ✔    |      | 再输出子类无参 |

6.

| 情况 | 父类 | 子类                        | 输出情况       |
| ---- | ---- | --------------------------- | -------------- |
| 无参 | ✔    |                             | 先输出父类无参 |
| 有参 | ✔    | ✔（无super或者有super（）） | 再输出子类有参 |

6.

| 情况 | 父类       | 子类              | 输出情况       |
| ---- | ---------- | ----------------- | -------------- |
| 无参 | ✔          |                   | 先输出父类有参 |
| 有参 | ✔（int i） | ✔（有super（i）） | 再输出子类有参 |

7.

| 情况 | 父类 | 子类 | 输出情况         |
| ---- | ---- | ---- | ---------------- |
| 无参 | ✔    | ✔    | 综合上述         |
| 有参 | ✔    | ✔    | 视使用情况而输出 |



## 2、父子类中各个资源的初始化顺序 

 静态优先，然后是父类型优先

```java
// 1、父亲的静态属性 (1)
// 2、子类的静态属性 (1)
// 3、初始化父亲中的属性
// 4、构造父亲实例
// 5、初始化子类中的属性
// 6、构造子类实例
```


## 3、子类和父类中调用方法的顺序

```java
Super s=new Super();	//父类
Sub b=new Sub();		//子类
```

- 采用**就近原则**
- 注意：父类的静态方法不能被子类重写，只可以继承，即使子类中的静态方法与父类中的静态方法完全一样，也是两个完全不同的方法
- 创建的对象是子类时，父类和子类都有这个方法时，就用子类的方法
- 创建的对象是子类时，父类有该方法，子类没有，调用父类的方法
- 创建的对象是父类时，只能使用父类的方法



## 4、多态以及方法的调用

- 多态

  > 简单地说就是：父类的引用指向了子类对象，接口的引用指向了其接口的实现类对象
  >
  > - 一个行为，在不同条件下，有不同的执行效果
  > - 在定义方法的时候，我们可以把参数类型定义的更为抽象一些，这样它就能接受所有的自类型实例，以此来提高程序的兼容性
  >
  > - 前提条件：必须存在继承或实现关系
  >
  > - 表现：重写是父类与子类之间多态性的一种表现，重载是一类中多态性的表现



- 父类  character =new 子类

  ~~~java
   Super e=new Sub();
  ~~~

- **能做什么看左边，具体做什么看右边**
  - 父类中有而子类没有的方法，使用父类
  - 父类和子类都有该方法时，使用子类重写的方法



- 父类的引用指向了子类对象（继承父类进行方法重写）

~~~java
public class Parent {
 
    public void fun(){}
}
 
public class Child extends Parent {

    @Override
    public void fun(){
        //子类的重写
    }
}

public class Demo1 {
	
	public static void main(String[] args) {
		Parent parent = new Child();
		parent.fun();
	}
}
~~~

- 同一个类中进行方法重载

  > 方法的重载：需参数不同、参数个数不同、返回值不同

~~~java
public void init(String name,int i){
        
}
    
public void init(int i,String name){
        
}
    
public void init(){
        
}
    
public int init(){
        
}
~~~



## 5、学生系统结构分析

Main	--主函数入口

StudentManager	--管家婆：定为属于高层管理，主要负责安排和协调工作的

StudentContainer、Console	--控制台、数据容器：中层管理，提供特定的服务、数据，这两者都直接与管家婆对接

自我感觉：精益求精，先列出StudentManager列出大概步骤，再通过下层实现具体方法



## 6、类型准换

- 主要分为向上（自动）和向下转型（需要在变量前面加以类型修饰）

  ~~~java
  //子类转父类(向上转型)
  Sub a=new Sub();
  Super s=a;
  //父类转子类(向下转型)
  Super a=new Super();
  Sub b=(Sub)a;
  ~~~

  

- 对于基本类型而言，比如数字，可以把长度小的类型自动转换成长度大的，相反，长度大的也可以强制类型转化为长度小的

  ~~~java
  byte(1字节)->short(2字节)->int(4字节)->long(8字节)->float(4字节)->double(8字节)
      	^
      	|
         char(2字节)
  ~~~

  

- 当把子类型转换为父类型的时候，这个实例的行为会变成它只能调用父类型声明的那些方法（能做什么看左边的类型，具体怎么做，看右边是什么样的实例）

  - 用法类似如多态

  

- 变量名 instanceof 类型：前者是后者这个类型的一个实例吗？

~~~java
Super n=new Sub();
 n instanceof Sub	结果：true
~~~



## 7、如何比较对象

- 如何比较对象
  - ==用来比较两者的地址(引用)，基本类型直接比较值
  - 我们如果要实现"当这个对象中某些个属性值相等，我们就认为这是两个相同的对象"，可以使用equals
  - 重写Object的equals方法（默认比较的是地址）
  - 比如用户在注册论坛的时候，我们可以在后台的User中，增加手机号码 + 性别 + 用户名



## 8、static修饰符的使用	

- 修饰变量：static修饰的变量不依赖类的实例而存在，一般直接通过类名进行调用，它是这个类的实例所有共有的（它只有一份）

  ~~~java
  如：public static int a=5；
  
  会在内存中只开辟一个空间，表名这是一个全局变量，不会再创建新的空间，static修饰的int等类型的值是可以改变的。
  ~~~

- 修饰方法：静态方法只能引用静态变量和静态方法

- **static一般都"只执行一次"或者"只有一份"**

- 静态代码块：只执行一次，并且时间点在构造器之前，在静态属性初始化之后



## 9、final修饰符的使用

- 被final修饰的变量，具有"不可改变"的特性，可以在构造器中进行第一次**赋值初始化**,**必须对每个构造器(无参和有参)里面进行同样的赋值操作**

- 修饰基本类型：其值不可以再进行修改

- 修饰引用类型：可以改 - 地址没有变（但凡是new了，地址一定改变了，如果通过setter进行修改，地址没有改变）

  ~~~java
  MyClass m=new MyClass();
  m=new Myclass;
  结果：报错
  ~~~

- 修饰类：这是这个类的最终版，不能被扩展和继承

- 修饰方法：这是这个方法的最终版，不能被重写



## 10、abstract修饰符的使用

- 修饰类：对于abstract方法，只允许声明，不允许实现（没有方法体）

  - 类里面可以有抽象的方法，也可以没有抽象方法（情况较少）

  - 类里面有抽象方法，它就一定是抽象类

  - 从用法上，主要是用来被继承的，它的子类必须要实现父类中的抽象方法，否则它自己也必须声明为abstract class

- 修饰方法： 会使这个方法变成抽象方法，也就是只有声明（定义）而没有实现，实现部分以”；”代替。需要子类继承实现（覆盖）
- 抽象类是可以继承普通类



## 11、final、static、abstract的共存

- final、abstract 不能共存（无论在类、方法、属性、局部变量上都不能共存）
  - 原因1:修饰类：final类表示完美不需要继承重写，abstract类表示要子类继承。
  - 原因2:修饰方法时：final表示完美不需要重写，只能子类继承使用，而abstract中的方法没有东西，所以并不完美。以上两点都是冲突的。故不成立。
- static、abstract 不能共存（无论在类、方法、属性、局部变量上都不能共存）
- final static field：定义的对象既要它是静态的，也要求它的值不能再被修改。
- final static method：该类成员方法不能被 override（重写）



## 12、接口

> 定义

- 接口：主要是用来封装一揽子抽象方法的，它侧重在于对行为的一种抽象（动词）

- 接口可以看作一个特殊的抽象类，但是两个是不同的概念，类描述对象的属性和方法，接口则包含类要实现的方法。\

- 接口中不能有具体的方法实现，它只是一种行为的规约（规范和约定）

> 语法特点

- 接口的实现类必须实现接口中的所有方法，只要有一个没有实现，这个类本身必须声明为abstract class

- 接口定义属性，默认是public final static，并且要对其初始化

- 接口定义方法，默认是public abstract

- JDK8 新特性：接口中其实可以定义具体方法（默认方法，可以定义多个），前面必须加default修饰

- 接口和其他类型之间的关系：
  - 接口和实现类之间的是implements，可以实现多个接口
  - 接口和接口之间是extends

> 作用

- 主要是为了解耦

~~~java
new User("Jack").eat();
new Animal("Pony").eat();
~~~

- 形成多态

~~~java
void run(IEat eat)
~~~

- 接口最终形成了一种跨界类型



## 13、接口内默认修饰符

```java
public interface Wifi {
// public abstract class Wifi {
    // 不是某某实例的成员变量，而是大家共有
    // 默认修饰符为public final static
    public final static int frequency = 100;

    // 默认修饰符为public abstract
    public abstract void connect();

}
```

- 子类重写父类方法时，方法的访问权限不能小于原访问权限，**在接口中，方法的默认权限就是public，所以子类重写后只能是public**



## 14、接口和抽象类的区别

1、接口和抽象类的概念是不一样的。**接口是对动作的抽象，表示的是这个对象能做什么**，比如人可以吃东西、狗也可以吃东西，只要有相同的行为；**抽象类是对根源的抽象，表示的是这个对象是什么**，比如男人是人、女人也是人

2、**可以实现多个接口，只能继承一个抽象类**

3、接口中只能定义抽象方法（除default方法），抽象类中可以有普通方法（第10个总结最后一点可以继承普通类的原因）

4、接口中只能有静态的不能被改变的数据成员，抽象类可以有普通的数据成员



## 15、抽象类实现接口，子类继承抽象类的关系

- 一个类实现一个接口，则该类必须实现该接口中的所有方法
- 一个抽象类实现一个接口，然后该**抽象类可以在该接口中实现任意数量的方法**

- （作业4第二题）一个类继承一个抽象类，这个抽象类实现一个接口，然后在这个子类中，**必须实现抽象类中未实现的接口方法和抽象的修改后的抽象方法**. 至于已经实现的接口方法或非抽象方法，可以重新实现或不实现



## 16、重写equals和hashCode的原因

- 没有重写hashCode方法，重写了equals，那么对象调用hashCode方法是根据对象的地址值来生成的哈希值,两个对象内容一定相同,哈希值不一定不同

- 重写了hashCode方法，没有重写equals，那么对象调用hashCode方法是根据对象的内容来生成的哈希值，两个对象哈希值相同,内容不一定相同

- 重写了equals和hashCode,两个对象内容相同,则哈希值一定相同,

- **重写hashcode是为了保证两个对象内容相等（equals）时哈希表key唯一的原则**

- **实际上重写了hashcode的两个对象的内存地址还是不相同的**

  




## 17、ArrayList与LinkedList

- ArrayList
  - 基于数组实现的，具备了数组所有的优点
  - 动态扩容
  - 随机查找（给定一个下标查找）快，插入删除慢

- LinkedList
  - 基于Node（节点）来实现的虚拟容器（没有具体的边界），每一个节点都会从"前"和"后"两个方向记住临近节点的信息
  - 理解双链表的操作
  - 随机访问慢，插入、删除快

- 个人实现LinkedList代码（单向和双向）

  - 单向实现（只有next，没有pre）

~~~java
    package com.zouzhao.linklist;
    
    import java.util.Stack;
    
    public class SingleLinkedListDemo {
        public static void main(String[] args) {
            HeroNode node1 = new HeroNode(1,"宋江","及时雨");
            HeroNode node2=new HeroNode(2,"林冲","豹子头");
            HeroNode node3 = new HeroNode(3, "李逵", "黑旋风");
            HeroNode node4=new HeroNode(4,"123","456");
    
            SingleLinkedList singleLinkedList = new SingleLinkedList();
            /*singleLinkedList.addHeroNode(node1);
            singleLinkedList.addHeroNode(node2);
            singleLinkedList.addHeroNode(node3);
            singleLinkedList.addHeroNode(node4);
    */
    
            //有序添加
            singleLinkedList.add2(node2);
            singleLinkedList.add2(node4);
            singleLinkedList.add2(node1);
            singleLinkedList.add2(node3);
    
            singleLinkedList.list();
    
            //替换，更新
            System.out.println("替换，更新");
            HeroNode newNode1=new HeroNode(4,"吴用","智多星");
            HeroNode newNode2 = new HeroNode(5, "123", "123");
    
            singleLinkedList.update(newNode1);
            singleLinkedList.list();
    
            singleLinkedList.update(newNode2);
            singleLinkedList.list();
    
    
            //删除
            System.out.println("删除");
            singleLinkedList.del(2);
            singleLinkedList.list();
            System.out.println();
            singleLinkedList.del(4);
            singleLinkedList.list();
            System.out.println();
            singleLinkedList.del(4);
            singleLinkedList.list();
            System.out.println();
    
            //得出有效节点
            System.out.println("有效节点");
            System.out.println(getLength(singleLinkedList.head));
    
            System.out.println("返回链表倒数第k个结点");
            System.out.println(findLastIndexNode(singleLinkedList.head, -2));
            System.out.println(findLastIndexNode(singleLinkedList.head, 2));
    
            System.out.println("原本的链表");
            singleLinkedList.list();
            System.out.println("反转列表");
            reversetList(singleLinkedList.head);
            singleLinkedList.list();
            System.out.println("2次反转列表利用stack");
           reversetListByStack(singleLinkedList.head);
            singleLinkedList.list();
    
            System.out.println("从尾到头打印");
            reversePrint(singleLinkedList.head);
    
            //复原
            System.out.println("");
            System.out.println("复原");
            /*HeroNode node1 = new HeroNode(1,"宋江","及时雨");
            HeroNode node2=new HeroNode(2,"林冲","豹子头");
            HeroNode node3 = new HeroNode(3, "李逵", "黑旋风");
            HeroNode node4=new HeroNode(4,"123","456");*/
            HeroNode node5= new HeroNode(5,"宋江","及时雨");
            HeroNode node6=new HeroNode(6,"林冲","豹子头");
            HeroNode node7 = new HeroNode(7, "李逵", "黑旋风");
            HeroNode node8=new HeroNode(8,"123","456");
            singleLinkedList.add2(node5);
            singleLinkedList.add2(node6);
            singleLinkedList.add2(node1);
            singleLinkedList.add2(node3);
    
            SingleLinkedList singleLinkedList2 = new SingleLinkedList();
            singleLinkedList2.add2(node2);
            singleLinkedList2.add2(node7);
            singleLinkedList2.add2(node4);
            singleLinkedList2.add2(node8);
    
            System.out.println("单链表1");
            singleLinkedList.list();
            System.out.println("单链表2");
            singleLinkedList2.list();
    
            System.out.println("合并两个有序的单链表，合并之后的链表依然有序【课后练习.】");
            lindedList1AndLinkedList2(singleLinkedList.head,singleLinkedList2.head);
            singleLinkedList.list();
        }
    
        /**
         *
         * @param head
         * @return 链表有效节点个数
         */
        public static int getLength(HeroNode head){
            if(head.next==null)return 0;//链表为空
            HeroNode temp=head.next;
            int count=0;
            while(true){
                if(temp==null)break;
                else count++;
                temp=temp.next;
            }
            return  count;
        }
    
        /**
         *
         * @param head
         * @param index
         * @return 返回链表倒数第k个结点
         */
        public static HeroNode findLastIndexNode(HeroNode head,int index){
            //链表为空
            if(head.next==null) return null;
    
            int length=getLength(head);
            //index必须在取值范围内
            if(index<=0||index>length)return null;
    
            HeroNode temp=head.next;
            for(int i=0;i<length-index;i++){
                temp=temp.next;
            }
            return temp;
        }
    
        /**
         *
         * @param head
         * 反转链表
         */
        public static void reversetList(HeroNode head){
            //判断链表为空或者只有一个结点，不需要反转
            if(head.next==null||head.next.next==null) return;
            //反转
            HeroNode temp,next,reverseHead;
            reverseHead=new HeroNode(0,"","");
            temp=head.next;
            while(true){
                if(temp==null)break;
                next=temp.next;
                //先连后面再连前面
                temp.next=reverseHead.next;
                reverseHead.next=temp;
    
                temp=next;
            }
            //将结果转移给原链表
            head.next=reverseHead.next;
        }
    
        /**
         *
         * @param head
         * 反转链表 利用栈
         */
        public static void reversetListByStack(HeroNode head){
            //判断是否为空或者一个结点
            if(head.next==null||head.next.next==null)return;
            //反转链表
            HeroNode reversetListHead=new HeroNode(0,"","");
            //压栈
            Stack<HeroNode> nodeStack = new Stack<>();
            HeroNode temp=head.next;
    
            while (true){
                if(temp==null)break;
                nodeStack.push(temp);
                temp=temp.next;
            }
            HeroNode uaa=reversetListHead;
            while(nodeStack.size()>0){
               HeroNode cur=nodeStack.pop();
                uaa.next=cur;
                cur.next=null;
                uaa=cur;
            }
            //转移
            head.next=reversetListHead.next;
    
        }
    
        /**
         *
         * @param head
         * 从尾到头打印单链表 利用栈stack
         */
        public static void reversePrint(HeroNode head){
            //判断是否为空或者一个结点
            if(head.next==null||head.next.next==null)return;
            //反转链表
            HeroNode reversetListHead=new HeroNode(0,"","");
            //压栈
            Stack<HeroNode> nodeStack = new Stack<>();
            HeroNode temp=head.next;
    
            while (true){
                if(temp==null)break;
                nodeStack.push(temp);
                temp=temp.next;
            }
    
            while(nodeStack.size()>0){
                HeroNode cur=nodeStack.pop();
                System.out.println(cur);
            }
        }
    
        /**
         * @param head1
         * @param head2
         * 合并两个有序的单链表，合并之后的链表依然有序【课后练习.】
         * 类似如按no大小插入,,t2插入t1
         */
        public static void lindedList1AndLinkedList2(HeroNode head1,HeroNode head2 ){
            if(head1.next==null&&head2==null)return;
    
            HeroNode temp2=head2.next;
            HeroNode temp1=head1;
            while(true) {
    
                if(temp2==null)break;//全部插入完
    
                //找到对应的no位置
                while (true) {
                    if (temp1.next == null) break;//遍历结束
                    if (temp2.no < temp1.next.no) break;//
                    temp1 = temp1.next;
                }
    
                HeroNode next = temp2.next;
                temp2.next = temp1.next;
                temp1.next = temp2;
                temp2=next;
            }
    
        }
    
        //定义单个实体,HeroNode
        static class HeroNode {
            int no;
            String name;
            String nickname;
            HeroNode next;
    
            //构造器
            public HeroNode(int no,String name,String nickname){
                this.no=no;
                this.name=name;
                this.nickname=nickname;
            }
    
            @Override
            public String toString() {
                return "HeroNode{" +
                        "no=" + no +
                        ", name='" + name + '\'' +
                        ", nickname='" + nickname + '\'' +
                        '}';
            }
        }
    
        //定义单链表和方法
        static class SingleLinkedList{
            private HeroNode head=new HeroNode(0,"","");
    
    
            //添加无顺序排名
            public void addHeroNode(HeroNode heroNode){
                HeroNode temp= head;
                while (true){
                    if(temp.next==null){
                        break;
                    }
                    temp=temp.next;
                }
    
                temp.next=heroNode;
            }
    
            //添加时按顺序进行添加
            public void add2(HeroNode heroNode){
                HeroNode temp=head;
                boolean flag=false;
                while(true){
                    if(temp.next==null)break;//遍历结束
                    if(heroNode.no<temp.next.no)break;//找到编号位置  1 2 3  *  5
                    else if(temp.next.no==heroNode.no)  //等于说明编号已存在
                    {
                        flag=true;
                        break;}
    
                    temp=temp.next; //后移
                }
                if(flag) {
                    System.out.println("编号已存在，无法进行添加");
                }
                else {
                    heroNode.next=temp.next;
                    temp.next=heroNode;
                }
            }
    
            //显示链表
            public void list(){
                HeroNode temp=head;
    
               while (true){
                   if(temp.next==null)break; //检查链表后面还有没有数据 //判断链表是否为空
                   System.out.println(temp.next);
                   temp=temp.next;
    
               }
            }
    
            //根据no修改链表
            public void update(HeroNode newHeroNode){
                HeroNode temp=head.next;
                boolean flag=false;
                while (true){
                    //遍历结束
                    if(temp==null)break;
                    if(newHeroNode.no== temp.no){
                        flag=true;
                       break;
                    }
                    temp=temp.next;
                }
    
                if(flag){
                    temp.name=newHeroNode.name;
                    temp.nickname=newHeroNode.nickname;
                    System.out.println("修改成功");
                }else {
                    System.out.println("没有找到该编号"+newHeroNode.no);
                }
            }
    
            //根据no删除
            public void del(int no){
                HeroNode temp=head;
                boolean flag=false;
                while(true){
                  if(temp.next==null)break;//遍历结束
                  if(temp.next.no==no){
                      flag=true;
                      break;
                  }
                  temp=temp.next;
                }
    
                if(flag){
                    temp.next=temp.next.next;
                }else System.out.println("没有该no");
    
            }
    
    
    
        }
    }
    
~~~
  双向实现（有pre和next）

~~~java
package com.zouzhao.linklist;

public class DoubleLinkedListDemo {
    public static void main(String[] args) {

    }


    //定义单个实体,HeroNode2
    static class HeroNode2 {
        int no;
        String name;
        String nickname;
        HeroNode2 next;
        HeroNode2 pre;

        //构造器
        public HeroNode2(int no,String name,String nickname){
            this.no=no;
            this.name=name;
            this.nickname=nickname;
        }

        @Override
        public String toString() {
            return "HeroNode2{" +
                    "no=" + no +
                    ", name='" + name + '\'' +
                    ", nickname='" + nickname + '\'' +
                    '}';
        }
    }


    class DoubleLinkedList{
        private HeroNode2 head=new HeroNode2(0,"","");


        //显示遍历链表
        public void list(){
            HeroNode2 temp=head;

            while (true){
                if(temp.next==null)break; //检查链表后面还有没有数据 //判断链表是否为空
                System.out.println(temp.next);
                temp=temp.next;

            }
        }
        
        //添加结点到链表末尾
        public void addHeroNode(HeroNode2 heroNode){
            HeroNode2 temp= head;
            while (true){
                if(temp.next==null){
                    break;
                }
                temp=temp.next;
            }
            //双向链表
            temp.next=heroNode;
            heroNode.pre=temp;
        }

        //根据no修改链表
        public void update(HeroNode2 newHeroNode){
            HeroNode2 temp=head.next;
            boolean flag=false;
            while (true){
                //遍历结束
                if(temp==null)break;
                if(newHeroNode.no== temp.no){
                    flag=true;
                    break;
                }
                temp=temp.next;
            }

            if(flag){
                temp.name=newHeroNode.name;
                temp.nickname=newHeroNode.nickname;
                System.out.println("修改成功");
            }else {
                System.out.println("没有找到该编号"+newHeroNode.no);
            }
        }

        //根据no删除
        public void del(int no){

            if(head.next==null){
                System.out.println("链表为空，无法删除");
            }
            HeroNode2 temp=head.next;
            boolean flag=false;
            while(true){
                if(temp==null)break;//遍历结束
                if(temp.no==no){
                    flag=true;
                    break;
                }
                temp=temp.next;
            }

            if(flag){
                temp.pre.next=temp.next;
                //如果为最后一个结点，就会出现空指针,要加一个判断是否为最后一个结点
                if(temp.next!=null){
                temp.next.pre=temp.pre;}

            }else System.out.println("没有该no");

        }
        
        
    }

}
~~~



## 18、HashMap和HaspSet

- Map
  - 基于键值对(key-value)的数据结构
  - key不能重复的，value可以重复
  - 元素的排列顺序无法得到保障的

- Set
  - 没有顺序
  - 没有下标
  - 元素不可以重复
  - 类似于一个大麻袋，里面只能装不重复的元素









# 问题收纳

## 1、如何理解类和对象

- 定义：类是关于一系列相似对象的概括描述，描述它们共有的状态、行为，通过这种共性的定义，我们可以重构出许许多多类似的对象。

​		而对象，即是根据上述类的定义，“克隆”产生的相关实例，这些实例往往在某些属性或行为上是类似但有细节不同的，比如都有姓名，但具体的名字不同。

- 组成类大体包含两种要素，我们统称为成员：
  - 成员变量：体现为属性、状态、数据
  - 成员方法：体现为函数或方法，或者做某件事情的能力

- 关系：类与对象之间的关系：当我们依照类A创建了a1实例的时候，我们可以说 a1 is a member of A



## 2、如何理解封装和抽象

- 封装（动词），既可以用于封装类型，也可以用于封装方法。

- 在封装类型的时候，即是把这个类型的2要素（成员变量和方法）包装到一个单元（class 文件）里面

- 在封装方法的时候，即是把专注做“某件事情”（执行某一个特定算法）的代码段用方法体包含起来

- 在封装的时候，要用“抽象”这种思维能力，做到关注主要的（所有实例共有的），忽略次要的（特别的，只有某些特殊实例才具备的）。

- 抽象还体现在，当我们使用一个类型的实例的时候，在调用其方法时，只需要关注有哪些入参，可以得到什么返回，而无需关注内部的具体实现方式或细节

























